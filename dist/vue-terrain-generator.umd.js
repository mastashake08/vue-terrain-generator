(function(I,h){typeof exports=="object"&&typeof module<"u"?module.exports=h(require("vue"),require("three"),require("simplex-noise")):typeof define=="function"&&define.amd?define(["vue","three","simplex-noise"],h):(I=typeof globalThis<"u"?globalThis:I||self,I.VueTerrainGenerator=h(I.Vue,I.THREE,I.SimplexNoise))})(this,function(I,h,X){"use strict";function J(o){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(o){for(const t in o)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(o,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>o[t]})}}return e.default=o,Object.freeze(e)}const R=J(h),k={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class z{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(e){return new oe(e)}),this.register(function(e){return new ae(e)}),this.register(function(e){return new fe(e)}),this.register(function(e){return new he(e)}),this.register(function(e){return new pe(e)}),this.register(function(e){return new de(e)}),this.register(function(e){return new ce(e)}),this.register(function(e){return new le(e)}),this.register(function(e){return new ue(e)}),this.register(function(e){return new xe(e)}),this.register(function(e){return new ye(e)}),this.register(function(e){return new ge(e)}),this.register(function(e){return new me(e)}),this.register(function(e){return new we(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}setTextureUtils(e){return this.textureUtils=e,this}parse(e,t,n,s){const r=new re,i=[];for(let a=0,c=this.pluginCallbacks.length;a<c;a++)i.push(this.pluginCallbacks[a](r));r.setPlugins(i),r.setTextureUtils(this.textureUtils),r.writeAsync(e,t,s).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(s,r){n.parse(e,s,r,t)})}}const m={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},G="KHR_mesh_quantization",L={};L[h.NearestFilter]=m.NEAREST,L[h.NearestMipmapNearestFilter]=m.NEAREST_MIPMAP_NEAREST,L[h.NearestMipmapLinearFilter]=m.NEAREST_MIPMAP_LINEAR,L[h.LinearFilter]=m.LINEAR,L[h.LinearMipmapNearestFilter]=m.LINEAR_MIPMAP_NEAREST,L[h.LinearMipmapLinearFilter]=m.LINEAR_MIPMAP_LINEAR,L[h.ClampToEdgeWrapping]=m.CLAMP_TO_EDGE,L[h.RepeatWrapping]=m.REPEAT,L[h.MirroredRepeatWrapping]=m.MIRRORED_REPEAT;const V={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},Z=new h.Color,j=12,$=1179937895,Q=2,Y=8,ee=1313821514,te=5130562;function F(o,e){return o.length===e.length&&o.every(function(t,n){return t===e[n]})}function se(o){return new TextEncoder().encode(o).buffer}function ne(o){return F(o.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function ie(o,e,t){const n={min:new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let r=0;r<o.itemSize;r++){let i;o.itemSize>4?i=o.array[s*o.itemSize+r]:(r===0?i=o.getX(s):r===1?i=o.getY(s):r===2?i=o.getZ(s):r===3&&(i=o.getW(s)),o.normalized===!0&&(i=h.MathUtils.normalize(i,o.array))),n.min[r]=Math.min(n.min[r],i),n.max[r]=Math.max(n.max[r],i)}return n}function K(o){return Math.ceil(o/4)*4}function D(o,e=0){const t=K(o.byteLength);if(t!==o.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(o)),e!==0)for(let s=o.byteLength;s<t;s++)n[s]=e;return n.buffer}return o}function q(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function W(o,e){if(o.toBlob!==void 0)return new Promise(n=>o.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),o.convertToBlob({type:e,quality:t})}class re{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+h.REVISION}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(e){this.plugins=e}setTextureUtils(e){this.textureUtils=e}async writeAsync(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(e),await Promise.all(this.pending);const s=this,r=s.buffers,i=s.json;n=s.options;const a=s.extensionsUsed,c=s.extensionsRequired,u=new Blob(r,{type:"application/octet-stream"}),x=Object.keys(a),l=Object.keys(c);if(x.length>0&&(i.extensionsUsed=x),l.length>0&&(i.extensionsRequired=l),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=u.size),n.binary===!0){const w=new FileReader;w.readAsArrayBuffer(u),w.onloadend=function(){const f=D(w.result),y=new DataView(new ArrayBuffer(Y));y.setUint32(0,f.byteLength,!0),y.setUint32(4,te,!0);const g=D(se(JSON.stringify(i)),32),p=new DataView(new ArrayBuffer(Y));p.setUint32(0,g.byteLength,!0),p.setUint32(4,ee,!0);const T=new ArrayBuffer(j),M=new DataView(T);M.setUint32(0,$,!0),M.setUint32(4,Q,!0);const C=j+p.byteLength+g.byteLength+y.byteLength+f.byteLength;M.setUint32(8,C,!0);const d=new Blob([T,p,g,y,f],{type:"application/octet-stream"}),A=new FileReader;A.readAsArrayBuffer(d),A.onloadend=function(){t(A.result)}}}else if(i.buffers&&i.buffers.length>0){const w=new FileReader;w.readAsDataURL(u),w.onloadend=function(){const f=w.result;i.buffers[0].uri=f,t(i)}}else t(i)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,s=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&r.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const i in r.gltfExtensions)t.extensions[i]=r.gltfExtensions[i],s[i]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new h.Vector3;for(let s=0,r=e.count;s<r;s++)if(Math.abs(n.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),s=new h.Vector3;for(let r=0,i=n.count;r<i;r++)s.fromBufferAttribute(n,r),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),n.setXYZ(r,s.x,s.y,s.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(s.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(e,t){if(e===t)return e;function n(f){return f.colorSpace===h.SRGBColorSpace?function(g){return g<.04045?g*.0773993808:Math.pow(g*.9478672986+.0521327014,2.4)}:function(g){return g}}e instanceof h.CompressedTexture&&(e=await this.decompressTextureAsync(e)),t instanceof h.CompressedTexture&&(t=await this.decompressTextureAsync(t));const s=e?e.image:null,r=t?t.image:null,i=Math.max(s?s.width:0,r?r.width:0),a=Math.max(s?s.height:0,r?r.height:0),c=q();c.width=i,c.height=a;const u=c.getContext("2d",{willReadFrequently:!0});u.fillStyle="#00ffff",u.fillRect(0,0,i,a);const x=u.getImageData(0,0,i,a);if(s){u.drawImage(s,0,0,i,a);const f=n(e),y=u.getImageData(0,0,i,a).data;for(let g=2;g<y.length;g+=4)x.data[g]=f(y[g]/256)*256}if(r){u.drawImage(r,0,0,i,a);const f=n(t),y=u.getImageData(0,0,i,a).data;for(let g=1;g<y.length;g+=4)x.data[g]=f(y[g]/256)*256}u.putImageData(x,0,0);const w=(e||t).clone();return w.source=new h.Source(c),w.colorSpace=h.NoColorSpace,w.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),w}async decompressTextureAsync(e,t=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(e,t)}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,s,r){const i=this.json;i.bufferViews||(i.bufferViews=[]);let a;switch(t){case m.BYTE:case m.UNSIGNED_BYTE:a=1;break;case m.SHORT:case m.UNSIGNED_SHORT:a=2;break;default:a=4}let c=e.itemSize*a;r===m.ARRAY_BUFFER&&(c=Math.ceil(c/4)*4);const u=K(s*c),x=new DataView(new ArrayBuffer(u));let l=0;for(let y=n;y<n+s;y++){for(let g=0;g<e.itemSize;g++){let p;e.itemSize>4?p=e.array[y*e.itemSize+g]:(g===0?p=e.getX(y):g===1?p=e.getY(y):g===2?p=e.getZ(y):g===3&&(p=e.getW(y)),e.normalized===!0&&(p=h.MathUtils.normalize(p,e.array))),t===m.FLOAT?x.setFloat32(l,p,!0):t===m.INT?x.setInt32(l,p,!0):t===m.UNSIGNED_INT?x.setUint32(l,p,!0):t===m.SHORT?x.setInt16(l,p,!0):t===m.UNSIGNED_SHORT?x.setUint16(l,p,!0):t===m.BYTE?x.setInt8(l,p):t===m.UNSIGNED_BYTE&&x.setUint8(l,p),l+=a}l%c!==0&&(l+=c-l%c)}const w={buffer:this.processBuffer(x.buffer),byteOffset:this.byteOffset,byteLength:u};return r!==void 0&&(w.target=r),r===m.ARRAY_BUFFER&&(w.byteStride=c),this.byteOffset+=u,i.bufferViews.push(w),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(s){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const i=D(r.result),a={buffer:t.processBuffer(i),byteOffset:t.byteOffset,byteLength:i.byteLength};t.byteOffset+=i.byteLength,s(n.bufferViews.push(a)-1)}})}processAccessor(e,t,n,s){const r=this.json,i={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=m.FLOAT;else if(e.array.constructor===Int32Array)a=m.INT;else if(e.array.constructor===Uint32Array)a=m.UNSIGNED_INT;else if(e.array.constructor===Int16Array)a=m.SHORT;else if(e.array.constructor===Uint16Array)a=m.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)a=m.BYTE;else if(e.array.constructor===Uint8Array)a=m.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),(s===void 0||s===1/0)&&(s=e.count),s===0)return null;const c=ie(e,n,s);let u;t!==void 0&&(u=e===t.index?m.ELEMENT_ARRAY_BUFFER:m.ARRAY_BUFFER);const x=this.processBufferView(e,a,n,s,u),l={bufferView:x.id,byteOffset:x.byteOffset,componentType:a,count:s,max:c.max,min:c.min,type:i[e.itemSize]};return e.normalized===!0&&(l.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(l)-1}processImage(e,t,n,s="image/png"){if(e!==null){const r=this,i=r.cache,a=r.json,c=r.options,u=r.pending;i.images.has(e)||i.images.set(e,{});const x=i.images.get(e),l=s+":flipY/"+n.toString();if(x[l]!==void 0)return x[l];a.images||(a.images=[]);const w={mimeType:s},f=q();f.width=Math.min(e.width,c.maxTextureSize),f.height=Math.min(e.height,c.maxTextureSize);const y=f.getContext("2d",{willReadFrequently:!0});if(n===!0&&(y.translate(0,f.height),y.scale(1,-1)),e.data!==void 0){t!==h.RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const p=new Uint8ClampedArray(e.height*e.width*4);for(let T=0;T<p.length;T+=4)p[T+0]=e.data[T+0],p[T+1]=e.data[T+1],p[T+2]=e.data[T+2],p[T+3]=e.data[T+3];y.putImageData(new ImageData(p,e.width,e.height),0,0)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)y.drawImage(e,0,0,f.width,f.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");c.binary===!0?u.push(W(f,s).then(p=>r.processBufferViewImage(p)).then(p=>{w.bufferView=p})):f.toDataURL!==void 0?w.uri=f.toDataURL(s):u.push(W(f,s).then(p=>new FileReader().readAsDataURL(p)).then(p=>{w.uri=p}));const g=a.images.push(w)-1;return x[l]=g,g}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:L[e.magFilter],minFilter:L[e.minFilter],wrapS:L[e.wrapS],wrapT:L[e.wrapT]};return t.samplers.push(n)-1}async processTextureAsync(e){const n=this.options,s=this.cache,r=this.json;if(s.textures.has(e))return s.textures.get(e);r.textures||(r.textures=[]),e instanceof h.CompressedTexture&&(e=await this.decompressTextureAsync(e,n.maxTextureSize));let i=e.userData.mimeType;i==="image/webp"&&(i="image/png");const a={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,i)};e.name&&(a.name=e.name),await this._invokeAllAsync(async function(u){u.writeTexture&&await u.writeTexture(e,a)});const c=r.textures.push(a)-1;return s.textures.set(e,c),c}async processMaterialAsync(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(F(r,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=1),e.metalnessMap||e.roughnessMap){const a=await this.buildMetalRoughTextureAsync(e.metalnessMap,e.roughnessMap),c={index:await this.processTextureAsync(a),texCoord:a.channel};this.applyTextureTransform(c,a),s.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const a={index:await this.processTextureAsync(e.map),texCoord:e.map.channel};this.applyTextureTransform(a,e.map),s.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive;if(Math.max(a.r,a.g,a.b)>0&&(s.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const u={index:await this.processTextureAsync(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(u,e.emissiveMap),s.emissiveTexture=u}}if(e.normalMap){const a={index:await this.processTextureAsync(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),s.normalTexture=a}if(e.aoMap){const a={index:await this.processTextureAsync(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),s.occlusionTexture=a}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===h.DoubleSide&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),await this._invokeAllAsync(async function(a){a.writeMaterialAsync&&await a.writeMaterialAsync(e,s)});const i=n.materials.push(s)-1;return t.materials.set(e,i),i}async processMeshAsync(e){const t=this.cache,n=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let d=0,A=e.material.length;d<A;d++)s.push(e.material[d].uuid);else s.push(e.material.uuid);const r=s.join(":");if(t.meshes.has(r))return t.meshes.get(r);const i=e.geometry;let a;e.isLineSegments?a=m.LINES:e.isLineLoop?a=m.LINE_LOOP:e.isLine?a=m.LINE_STRIP:e.isPoints?a=m.POINTS:a=e.material.wireframe?m.LINES:m.TRIANGLES;const c={},u={},x=[],l=[],w={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},f=i.getAttribute("normal");f!==void 0&&!this.isNormalizedNormalAttribute(f)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(f)));let y=null;for(let d in i.attributes){if(d.slice(0,5)==="morph")continue;const A=i.attributes[d];if(d=w[d]||d.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(d)||(d="_"+d),t.attributes.has(this.getUID(A))){u[d]=t.attributes.get(this.getUID(A));continue}y=null;const b=A.array;d==="JOINTS_0"&&!(b instanceof Uint16Array)&&!(b instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),y=new h.BufferAttribute(new Uint16Array(b),A.itemSize,A.normalized)):(b instanceof Uint32Array||b instanceof Int32Array)&&!d.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${d}" converted to type FLOAT.`),y=z.Utils.toFloat32BufferAttribute(A));const E=this.processAccessor(y||A,i);E!==null&&(d.startsWith("_")||this.detectMeshQuantization(d,A),u[d]=E,t.attributes.set(this.getUID(A),E))}if(f!==void 0&&i.setAttribute("normal",f),Object.keys(u).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const d=[],A=[],S={};if(e.morphTargetDictionary!==void 0)for(const b in e.morphTargetDictionary)S[e.morphTargetDictionary[b]]=b;for(let b=0;b<e.morphTargetInfluences.length;++b){const E={};let H=!1;for(const O in i.morphAttributes){if(O!=="position"&&O!=="normal"){H||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),H=!0);continue}const _=i.morphAttributes[O][b],P=O.toUpperCase(),v=i.attributes[O];if(t.attributes.has(this.getUID(_,!0))){E[P]=t.attributes.get(this.getUID(_,!0));continue}const B=_.clone();if(!i.morphTargetsRelative)for(let N=0,be=_.count;N<be;N++)for(let U=0;U<_.itemSize;U++)U===0&&B.setX(N,_.getX(N)-v.getX(N)),U===1&&B.setY(N,_.getY(N)-v.getY(N)),U===2&&B.setZ(N,_.getZ(N)-v.getZ(N)),U===3&&B.setW(N,_.getW(N)-v.getW(N));E[P]=this.processAccessor(B,i),t.attributes.set(this.getUID(v,!0),E[P])}l.push(E),d.push(e.morphTargetInfluences[b]),e.morphTargetDictionary!==void 0&&A.push(S[b])}c.weights=d,A.length>0&&(c.extras={},c.extras.targetNames=A)}const g=Array.isArray(e.material);if(g&&i.groups.length===0)return null;let p=!1;if(g&&i.index===null){const d=[];for(let A=0,S=i.attributes.position.count;A<S;A++)d[A]=A;i.setIndex(d),p=!0}const T=g?e.material:[e.material],M=g?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let d=0,A=M.length;d<A;d++){const S={mode:a,attributes:u};if(this.serializeUserData(i,S),l.length>0&&(S.targets=l),i.index!==null){let E=this.getUID(i.index);(M[d].start!==void 0||M[d].count!==void 0)&&(E+=":"+M[d].start+":"+M[d].count),t.attributes.has(E)?S.indices=t.attributes.get(E):(S.indices=this.processAccessor(i.index,i,M[d].start,M[d].count),t.attributes.set(E,S.indices)),S.indices===null&&delete S.indices}const b=await this.processMaterialAsync(T[M[d].materialIndex]);b!==null&&(S.material=b),x.push(S)}p===!0&&i.setIndex(null),c.primitives=x,n.meshes||(n.meshes=[]),await this._invokeAllAsync(function(d){d.writeMesh&&d.writeMesh(e,c)});const C=n.meshes.push(c)-1;return t.meshes.set(r,C),C}detectMeshQuantization(e,t){if(this.extensionsUsed[G])return;let n;switch(t.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}t.normalized&&(n+=" normalized");const s=e.split("_",1)[0];k[s]&&k[s].includes(n)&&(this.extensionsUsed[G]=!0,this.extensionsRequired[G]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,s={type:n?"orthographic":"perspective"};return n?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:h.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const n=this.json,s=this.nodeMap;n.animations||(n.animations=[]),e=z.Utils.mergeMorphTargetTracks(e.clone(),t);const r=e.tracks,i=[],a=[];for(let c=0;c<r.length;++c){const u=r[c],x=h.PropertyBinding.parseTrackName(u.name);let l=h.PropertyBinding.findNode(t,x.nodeName);const w=V[x.propertyName];if(x.objectName==="bones"&&(l.isSkinnedMesh===!0?l=l.skeleton.getBoneByName(x.objectIndex):l=void 0),!l||!w){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',u.name);continue}const f=1;let y=u.values.length/u.times.length;w===V.morphTargetInfluences&&(y/=l.morphTargetInfluences.length);let g;u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(g="CUBICSPLINE",y/=3):u.getInterpolation()===h.InterpolateDiscrete?g="STEP":g="LINEAR",a.push({input:this.processAccessor(new h.BufferAttribute(u.times,f)),output:this.processAccessor(new h.BufferAttribute(u.values,y)),interpolation:g}),i.push({sampler:a.length-1,target:{node:s.get(l),path:w}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:a,channels:i}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,s=t.nodes[n.get(e)],r=e.skeleton;if(r===void 0)return null;const i=e.skeleton.bones[0];if(i===void 0)return null;const a=[],c=new Float32Array(r.bones.length*16),u=new h.Matrix4;for(let l=0;l<r.bones.length;++l)a.push(n.get(r.bones[l])),u.copy(r.boneInverses[l]),u.multiply(e.bindMatrix).toArray(c,l*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new h.BufferAttribute(c,16)),joints:a,skeleton:n.get(i)}),s.skin=t.skins.length-1}async processNodeAsync(e){const t=this.json,n=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(n.trs){const a=e.quaternion.toArray(),c=e.position.toArray(),u=e.scale.toArray();F(a,[0,0,0,1])||(r.rotation=a),F(c,[0,0,0])||(r.translation=c),F(u,[1,1,1])||(r.scale=u)}else e.matrixAutoUpdate&&e.updateMatrix(),ne(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const a=await this.processMeshAsync(e);a!==null&&(r.mesh=a)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let c=0,u=e.children.length;c<u;c++){const x=e.children[c];if(x.visible||n.onlyVisible===!1){const l=await this.processNodeAsync(x);l!==null&&a.push(l)}}a.length>0&&(r.children=a)}await this._invokeAllAsync(function(a){a.writeNode&&a.writeNode(e,r)});const i=t.nodes.push(r)-1;return s.set(e,i),i}async processSceneAsync(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const r=[];for(let i=0,a=e.children.length;i<a;i++){const c=e.children[i];if(c.visible||n.onlyVisible===!1){const u=await this.processNodeAsync(c);u!==null&&r.push(u)}}r.length>0&&(s.nodes=r),this.serializeUserData(e,s)}async processObjectsAsync(e){const t=new h.Scene;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);await this.processSceneAsync(t)}async processInputAsync(e){const t=this.options;e=e instanceof Array?e:[e],await this._invokeAllAsync(function(s){s.beforeParse&&s.beforeParse(e)});const n=[];for(let s=0;s<e.length;s++)e[s]instanceof h.Scene?await this.processSceneAsync(e[s]):n.push(e[s]);n.length>0&&await this.processObjectsAsync(n);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);await this._invokeAllAsync(function(s){s.afterParse&&s.afterParse(e)})}async _invokeAllAsync(e){for(let t=0,n=this.plugins.length;t<n;t++)await e(this.plugins[t])}}class oe{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,s=n.json,r=n.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(1-e.penumbra)*e.angle,i.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},r[this.name]=!0);const a=s.extensions[this.name].lights;a.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}class ae{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}async writeMaterialAsync(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class ce{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const i={index:await n.processTextureAsync(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(i,e.clearcoatMap),r.clearcoatTexture=i}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const i={index:await n.processTextureAsync(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(i,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=i}if(e.clearcoatNormalMap){const i={index:await n.processTextureAsync(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};e.clearcoatNormalScale.x!==1&&(i.scale=e.clearcoatNormalScale.x),n.applyTextureTransform(i,e.clearcoatNormalMap),r.clearcoatNormalTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class le{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.dispersion===0)return;const s=this.writer.extensionsUsed,r={};r.dispersion=e.dispersion,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class ue{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const i={index:await n.processTextureAsync(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(i,e.iridescenceMap),r.iridescenceTexture=i}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const i={index:await n.processTextureAsync(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(i,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class fe{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const i={index:await n.processTextureAsync(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(i,e.transmissionMap),r.transmissionTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class he{constructor(e){this.writer=e,this.name="KHR_materials_volume"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const i={index:await n.processTextureAsync(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(i,e.thicknessMap),r.thicknessTexture=i}e.attenuationDistance!==1/0&&(r.attenuationDistance=e.attenuationDistance),r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class pe{constructor(e){this.writer=e,this.name="KHR_materials_ior"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const s=this.writer.extensionsUsed,r={};r.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class de{constructor(e){this.writer=e,this.name="KHR_materials_specular"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(Z)&&!e.specularIntensityMap&&!e.specularColorMap)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.specularIntensityMap){const i={index:await n.processTextureAsync(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(i,e.specularIntensityMap),r.specularTexture=i}if(e.specularColorMap){const i={index:await n.processTextureAsync(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(i,e.specularColorMap),r.specularColorTexture=i}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class xe{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.sheenRoughnessMap){const i={index:await n.processTextureAsync(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(i,e.sheenRoughnessMap),r.sheenRoughnessTexture=i}if(e.sheenColorMap){const i={index:await n.processTextureAsync(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(i,e.sheenColorMap),r.sheenColorTexture=i}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class ye{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(e,t){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.anisotropyMap){const i={index:await n.processTextureAsync(e.anisotropyMap)};n.applyTextureTransform(i,e.anisotropyMap),r.anisotropyTexture=i}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class ge{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(e,t){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const s=this.writer.extensionsUsed,r={};r.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class me{constructor(e){this.writer=e,this.name="EXT_materials_bump"}async writeMaterialAsync(e,t){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const n=this.writer,s=n.extensionsUsed,r={};if(e.bumpMap){const i={index:await n.processTextureAsync(e.bumpMap),texCoord:e.bumpMap.channel};n.applyTextureTransform(i,e.bumpMap),r.bumpTexture=i}r.bumpFactor=e.bumpScale,t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class we{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,t){if(!e.isInstancedMesh)return;const n=this.writer,s=e,r=new Float32Array(s.count*3),i=new Float32Array(s.count*4),a=new Float32Array(s.count*3),c=new h.Matrix4,u=new h.Vector3,x=new h.Quaternion,l=new h.Vector3;for(let f=0;f<s.count;f++)s.getMatrixAt(f,c),c.decompose(u,x,l),u.toArray(r,f*3),x.toArray(i,f*4),l.toArray(a,f*3);const w={TRANSLATION:n.processAccessor(new h.BufferAttribute(r,3)),ROTATION:n.processAccessor(new h.BufferAttribute(i,4)),SCALE:n.processAccessor(new h.BufferAttribute(a,3))};s.instanceColor&&(w._COLOR_0=n.processAccessor(s.instanceColor)),t.extensions=t.extensions||{},t.extensions[this.name]={attributes:w},n.extensionsUsed[this.name]=!0,n.extensionsRequired[this.name]=!0}}z.Utils={insertKeyframe:function(o,e){const n=o.getValueSize(),s=new o.TimeBufferType(o.times.length+1),r=new o.ValueBufferType(o.values.length+n),i=o.createInterpolant(new o.ValueBufferType(n));let a;if(o.times.length===0){s[0]=e;for(let c=0;c<n;c++)r[c]=0;a=0}else if(e<o.times[0]){if(Math.abs(o.times[0]-e)<.001)return 0;s[0]=e,s.set(o.times,1),r.set(i.evaluate(e),0),r.set(o.values,n),a=0}else if(e>o.times[o.times.length-1]){if(Math.abs(o.times[o.times.length-1]-e)<.001)return o.times.length-1;s[s.length-1]=e,s.set(o.times,0),r.set(o.values,0),r.set(i.evaluate(e),o.values.length),a=s.length-1}else for(let c=0;c<o.times.length;c++){if(Math.abs(o.times[c]-e)<.001)return c;if(o.times[c]<e&&o.times[c+1]>e){s.set(o.times.slice(0,c+1),0),s[c+1]=e,s.set(o.times.slice(c+1),c+2),r.set(o.values.slice(0,(c+1)*n),0),r.set(i.evaluate(e),(c+1)*n),r.set(o.values.slice((c+1)*n),(c+2)*n),a=c+1;break}}return o.times=s,o.values=r,a},mergeMorphTargetTracks:function(o,e){const t=[],n={},s=o.tracks;for(let r=0;r<s.length;++r){let i=s[r];const a=h.PropertyBinding.parseTrackName(i.name),c=h.PropertyBinding.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(h.InterpolateLinear)}const u=c.morphTargetInfluences.length,x=c.morphTargetDictionary[a.propertyIndex];if(x===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let l;if(n[c.uuid]===void 0){l=i.clone();const f=new l.ValueBufferType(u*l.times.length);for(let y=0;y<l.times.length;y++)f[y*u+x]=l.values[y];l.name=(a.nodeName||"")+".morphTargetInfluences",l.values=f,n[c.uuid]=l,t.push(l);continue}const w=i.createInterpolant(new i.ValueBufferType(1));l=n[c.uuid];for(let f=0;f<l.times.length;f++)l.values[f*u+x]=w.evaluate(l.times[f]);for(let f=0;f<i.times.length;f++){const y=this.insertKeyframe(l,i.times[f]);l.values[y*u+x]=i.values[f]}}return o.tracks=t,o},toFloat32BufferAttribute:function(o){const e=new h.BufferAttribute(new Float32Array(o.count*o.itemSize),o.itemSize,!1);if(!o.normalized&&!o.isInterleavedBufferAttribute)return e.array.set(o.array),e;for(let t=0,n=o.count;t<n;t++)for(let s=0;s<o.itemSize;s++)e.setComponent(t,s,o.getComponent(t,s));return e}};const Te=I.defineComponent({name:"TerrainGenerator",props:{terrainSize:{type:Number,default:1e3},segments:{type:Number,default:512},heightScaling:{type:Number,default:80},terrainColor:{type:String,default:"#88cc88"},backgroundColor:{type:String,default:"#000000"},noiseType:{type:String,default:"simplex"},noiseScale:{type:Number,default:.02},enableAnimation:{type:Boolean,default:!1},animationSpeed:{type:Number,default:.005}},setup(o,{expose:e}){const t=I.ref(null);let n,s,r,i,a,c=new X,u=new R.Clock;const x=()=>{new z().parse(n,T=>{const M=new Blob([JSON.stringify(T)],{type:"application/json"}),C=URL.createObjectURL(M),d=document.createElement("a");d.style.display="none",d.href=C,d.download="random_terrain.gltf",document.body.appendChild(d),d.click(),document.body.removeChild(d)})},l=I.reactive({terrainSize:o.terrainSize,segments:o.segments,heightScaling:o.heightScaling,terrainColor:o.terrainColor,backgroundColor:o.backgroundColor,noiseType:o.noiseType,noiseScale:o.noiseScale,enableAnimation:o.enableAnimation,animationSpeed:o.animationSpeed}),w=p=>{const T=p.attributes.position.array;for(let M=0;M<T.length;M+=3){const C=T[M]*l.noiseScale,d=T[M+2]*l.noiseScale,A=c.noise2D(C,d);T[M+1]=A*l.heightScaling}p.computeVertexNormals()},f=()=>{if(!t.value)return;n=new R.Scene,n.background=new R.Color(l.backgroundColor),s=new R.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3),s.position.set(0,100,200),r=new R.WebGLRenderer({antialias:!0}),r.setSize(window.innerWidth,window.innerHeight),t.value.appendChild(r.domElement);const p=new R.PlaneGeometry(l.terrainSize,l.terrainSize,l.segments,l.segments);p.rotateX(-Math.PI/2),w(p);const T=new R.MeshStandardMaterial({color:l.terrainColor});i=new R.Mesh(p,T),n.add(i);const M=new R.DirectionalLight(16777215,1);M.position.set(500,500,500).normalize(),n.add(M),y()},y=()=>{if(l.enableAnimation){const p=u.getElapsedTime();i.rotation.y+=l.animationSpeed;const T=i.geometry.attributes.position.array;for(let M=0;M<T.length;M+=3)T[M+1]=Math.sin(p+T[M]*.01+T[M+2]*.01)*2;i.geometry.attributes.position.needsUpdate=!0}r.render(n,s),a=requestAnimationFrame(y)},g=async p=>{Object.assign(l,p),n.clear(),await I.nextTick(),f()};return I.onMounted(async()=>{await I.nextTick(),f()}),I.onUnmounted(()=>{cancelAnimationFrame(a),r.dispose()}),e({updateSettings:g}),{threeContainer:t,downloadTerrain:x}}}),Me=(o,e)=>{const t=o.__vccOpts||o;for(const[n,s]of e)t[n]=s;return t},Ae={ref:"threeContainer",style:{width:"100%",height:"100vh"}};function Ie(o,e,t,n,s,r){return I.openBlock(),I.createElementBlock("div",null,[I.createElementVNode("button",{onClick:e[0]||(e[0]=(...i)=>o.downloadTerrain&&o.downloadTerrain(...i))},"Generate & Download Terrain"),I.createElementVNode("div",Ae,null,512)])}return Me(Te,[["render",Ie]])});
